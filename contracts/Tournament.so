//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "./StringUtils.sol";
import "hardhat/console.sol";

contract Tournament is Ownable {

  using SafeMath for uint256;
  // global position variabel; used when players are joining
  uint256 public position;

  // game variables;
  uint256 startBlock;
  uint256 public players;
  uint256 public rounds;
  uint256 public betAmount;
  address public devAddr;
  uint8 public devFee; // percentage
  uint256 public pot;
  string private domain;
  IERC20 token;
  
  struct Player {
    uint256 position;
    uint256 round;
  }

  // addresses maps to structs, addresses are stored in array
  mapping (address => Player) public mPlayers;
  address[] public aPlayers;
  
  // contructor
  constructor(address _token, address _devAddr, uint8 _devFee) public {
    devAddr = _devAddr;
    devFee = _devFee;
    token = IERC20(_token);
  }

  // owner funciton
  function setDomain(string memory _domain) public {
    domain = _domain;
  }
  function setDevAddr (address _devAddr) public {
    devAddr = _devAddr;
  }

  function setDevFee (uint8 _devFee) public {
    devFee = _devFee;
  }

  function setTournament(uint256 _startBlock, uint256 _players, uint256 _betAmount) public {
    startBlock = _startBlock;
    players = _players;
    betAmount = _betAmount;
    rounds = log2(_players);
  }

  function log2(uint x) internal returns (uint y){
    assembly {
      let arg := x
      x := sub(x,1)
      x := or(x, div(x, 0x02))
      x := or(x, div(x, 0x04))
      x := or(x, div(x, 0x10))
      x := or(x, div(x, 0x100))
      x := or(x, div(x, 0x10000))
      x := or(x, div(x, 0x100000000))
      x := or(x, div(x, 0x10000000000000000))
      x := or(x, div(x, 0x100000000000000000000000000000000))
      x := add(x, 1)
      let m := mload(0x40)
      mstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)
      mstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)
      mstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)
      mstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)
      mstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)
      mstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)
      mstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)
      mstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)
      mstore(0x40, add(m, 0x100))
      let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff
      let shift := 0x100000000000000000000000000000000000000000000000000000000000000
      let a := div(mul(x, magic), shift)
      y := div(mload(add(m,sub(255,a))), shift)
      y := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))
    }  
 }
  function join() public {
    require(block.timestamp > startBlock, "Tournament not started!");
    require(position < players, "tournament is full");
    // players are assigned a position
    require(mPlayers[msg.sender].position == 0, "You are already joined!");
    position++;
    mPlayers[msg.sender].position = position;
     // added into the array (based on their position)
    aPlayers.push(msg.sender);
    uint256 realAmount = betAmount;
    if(devFee > 0) {
      realAmount -= realAmount.mul(devFee).div(100);
    }
    token.transferFrom(msg.sender, address(this), realAmount);
    pot += realAmount;
  }

  // for finding player's opponent, receives player's address and returns opponent's address
  function find(address _player) external view returns (address) {
    // same as above: used to determine whether player's position is even or odd
    uint x = mPlayers[_player].position;
    uint y = mPlayers[_player].round;
    uint z = (x - 1) / 2 ** y + 1;
    uint opponent;

    // even number, opponent's position is 2 ** y (player's round) less than player's position
    if (z % 2 == 0) {
      // subtract one for array
      opponent = (x - 2 ** y) - 1;
      // odd number, opponent's position is 2 ** y more
    } else {
      opponent = (x + 2 ** y) - 1;
    }

    // opponent must be in same round as player
    if (mPlayers[aPlayers[opponent]].round == y) {
      return aPlayers[opponent];
    }
  }

  // clears all relevant arrays and mappings for new tournament
  function _clear() internal {
    // for deleting mapping, iteration is required
    for (uint i = 0; i < aPlayers.length; i++) {
      delete mPlayers[aPlayers[i]];
    }
    delete aPlayers;
  }

  function processResult(bytes memory hashData) public {
    string memory _domain;
    address _winner;
    address _loser;
    (_domain, _winner, _loser) = abi.decode(hashData, (string, address, address));
    require(StringUtils.equal(domain, _domain), "Invalid call!");
    require(msg.sender == _winner || msg.sender == _loser, "Invalid user!");
    if(msg.sender == _winner) {
      uint x = mPlayers[_winner].position;
      uint y = mPlayers[_winner].round;
      uint z = (x - 1) / 2 ** y + 1;

      mPlayers[_winner].round++;

      if (mPlayers[_winner].round == rounds) {
        // tranfer champion prize
        _tranfer(msg.sender, rounds);
        // format tournament
        _clear();
      } else {
        // player's position only changes if it is even, otherwise it stays the same
        if (z % 2 == 0) {
          mPlayers[_winner].position = x - 2 ** y;
          // must subtract one from position because arrays start from zero
          aPlayers[(x - 2 ** y) - 1] = _winner;
        }
        // loser is disqualified
        mPlayers[_loser].position = 0;
      }
    } else {
      // transfer player's share
      _tranfer(msg.sender, mPlayers[_loser].round);
    }
  }

  function pendingPrize(address player) public view returns (uint256) {
    uint256 amount;
    uint256 _round = mPlayers[player].round;
    if (_round == rounds) {
      amount = pot * 30 / 100; // for champion
    } else if (_round == rounds - 1) {
      amount = pot * 15 / 100; // for 2nd place
    } else if (_round == rounds - 2) {
      amount = pot * 10 / 100;
    } else if (_round == rounds - 3) {
      amount = pot * 5 / 100;
    } else if (_round == rounds - 4) {
      amount = pot * 15 / 100 / 8;
    }
    return amount;
  }

  function _tranfer(address to, uint256 _round) internal {
    uint256 amount = pendingPrize(to);
    token.transfer(to, amount);
  }
}